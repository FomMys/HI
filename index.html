<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>GLITCHRUNNER</title>

<style>
body {
    margin: 0;
    overflow: hidden;
    background: black;
    font-family: 'Courier New', monospace;
    color: cyan;
}
#gameCanvas { display:block; image-rendering:pixelated }
#ui {
    position:absolute;
    top:10px;
    left:10px;
    font-size:14px;
}
.cooldown {
    height:4px;
    background:cyan;
    margin-top:2px;
}
#corruptionMeter {
    position:absolute;
    bottom:20px;
    left:20px;
    width:200px;
    height:10px;
    border:1px solid cyan;
}
#corruptionFill {
    height:100%;
    background:purple;
}
.glitchText {
    animation: glitch 0.1s infinite;
}
@keyframes glitch {
    0%{transform:translate(0)}
    50%{transform:translate(-1px,1px)}
    100%{transform:translate(0)}
}
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>

<div id="ui">
LEVEL <span id="levelDisplay"></span> |
HP <span id="healthDisplay"></span>%
<div>Z<div id="zcd" class="cooldown"></div></div>
<div>X<div id="xcd" class="cooldown"></div></div>
<div>C<div id="ccd" class="cooldown"></div></div>
</div>

<div id="corruptionMeter"><div id="corruptionFill"></div></div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = innerWidth;
canvas.height = innerHeight;

let level=1, health=100, corruption=0;
let enemies=[], projectiles=[], platforms=[];
let shake=0;

const player = {
    x:50,y:canvas.height-100,w:20,h:40,
    vy:0,jumping:false,
    zcd:0,xcd:0,ccd:0
};

const keys={};

function updateUI(){
    levelDisplay.textContent=level;
    healthDisplay.textContent=health;
    corruptionFill.style.width=corruption+"%";
    zcd.style.width=(player.zcd/60*100)+"%";
    xcd.style.width=(player.xcd/120*100)+"%";
    ccd.style.width=(player.ccd/180*100)+"%";
}

function collide(a,b){
    return a.x<a.w+b.x && a.x+a.w>b.x &&
           a.y<a.h+b.y && a.y+a.h>b.y;
}

function initLevel(){
    enemies=[]; projectiles=[]; platforms=[];
    for(let i=0;i<5+level;i++){
        platforms.push({
            x:Math.random()*(canvas.width-120),
            y:canvas.height-50-i*100,
            w:80+Math.random()*80,h:10
        });
    }

    const boss = level%5===0;
    for(let i=0;i<(boss?1:level);i++){
        enemies.push({
            x:Math.random()*canvas.width,
            y:platforms[i%platforms.length].y-40,
            w: boss?60:20,
            h: boss?80:30,
            hp: boss?20:2,
            type: boss?"boss":["patrol","shooter","charger"][Math.floor(Math.random()*3)],
            speed: boss?1:1+Math.random(),
            base:0, dir:Math.random()>0.5?1:-1,
            shoot:0, slow:0, hitFlash:0
        });
        enemies.at(-1).base=enemies.at(-1).speed;
    }
    player.x=50; player.y=canvas.height-100;
    corruption=Math.min(corruption,90);
    updateUI();
}

function gameLoop(){
    let ox=0,oy=0;
    if(shake){ ox=(Math.random()-0.5)*shake; oy=(Math.random()-0.5)*shake; shake*=0.9; }
    ctx.setTransform(1,0,0,1,ox,oy);
    ctx.clearRect(-ox,-oy,canvas.width,canvas.height);

    if(corruption>60 && Math.random()<0.05) shake=5;

    ctx.fillStyle=corruption>50?"#110011":"black";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    platforms.forEach(p=>{
        ctx.fillStyle="#333";
        ctx.fillRect(p.x,p.y,p.w,p.h);
    });

    if(keys.ArrowLeft) player.x-=5;
    if(keys.ArrowRight) player.x+=5;
    if(keys.ArrowUp && !player.jumping){
        player.vy=-12; player.jumping=true;
    }

    player.vy+=0.5;
    const oldY=player.y;
    player.y+=player.vy;

    platforms.forEach(p=>{
        if(player.x<p.x+p.w && player.x+player.w>p.x){
            if(oldY+player.h<=p.y && player.y+player.h>=p.y){
                player.y=p.y-player.h;
                player.vy=0; player.jumping=false;
            }
        }
    });

    if(player.y>canvas.height){ health-=10; player.y=0; updateUI(); }

    if(keys.z && player.zcd<=0){
        player.x+=150*(keys.ArrowLeft?-1:1);
        corruption+=5; player.zcd=60;
    }
    if(keys.x && player.xcd<=0){
        corruption+=8; player.xcd=120;
        enemies.forEach(e=>{
            if(Math.abs(e.x-player.x)<200){
                e.slow=120;
            }
        });
    }
    if(keys.c && player.ccd<=0 && health<100){
        corruption+=15; health=Math.min(100,health+30);
        player.ccd=180; updateUI();
    }

    if(player.zcd)player.zcd--;
    if(player.xcd)player.xcd--;
    if(player.ccd)player.ccd--;

    ctx.fillStyle=corruption>70?"purple":"cyan";
    ctx.fillRect(player.x,player.y,player.w,player.h);

    enemies.forEach(e=>{
        if(e.slow){ e.speed=e.base*0.3; e.slow--; }
        else e.speed=e.base;

        if(e.type==="charger" && Math.abs(player.x-e.x)<200){
            e.x+=e.speed*Math.sign(player.x-e.x);
            if(Math.random()<0.02 && !e.jumping){ e.vy=-10; e.jumping=true; }
        }

        if(e.type==="shooter"){
            e.shoot--;
            if(e.shoot<=0){
                projectiles.push({
                    x:e.x,y:e.y,
                    vx:(player.x-e.x)/50,
                    vy:(player.y-e.y)/50
                });
                e.shoot=90;
            }
        }

        if(e.hitFlash>0){ ctx.fillStyle="white"; e.hitFlash--; }
        else ctx.fillStyle="red";
        ctx.fillRect(e.x,e.y,e.w,e.h);
    });

    projectiles.forEach((p,i)=>{
        p.x+=p.vx*3; p.y+=p.vy*3;
        ctx.fillStyle="yellow";
        ctx.fillRect(p.x,p.y,4,4);
        if(p.x<0||p.x>canvas.width) projectiles.splice(i,1);
        if(collide(player,{x:p.x,y:p.y,w:4,h:4})){
            health-=10; projectiles.splice(i,1); updateUI();
        }
    });

    if(enemies.length===0){
        level++; initLevel();
    }
    if(health<=0){
        alert("PROCESS TERMINATED");
        level=1; health=100; corruption=0;
        initLevel();
    }

    ui.className=corruption>70?"glitchText":"";
    corruption=Math.min(100,corruption);
    updateUI();
    requestAnimationFrame(gameLoop);
}

onkeydown=e=>keys[e.key]=true;
onkeyup=e=>keys[e.key]=false;
onresize=()=>{canvas.width=innerWidth;canvas.height=innerHeight};

initLevel();
gameLoop();
</script>
</body>
</html>
